// Copyright (c) the JPEG XL Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef JXL_DCT_SCALES_H_
#define JXL_DCT_SCALES_H_

// Scaling factors.

#include <stddef.h>

namespace jxl {
template <size_t V>
struct square_root {
  static constexpr float value = square_root<V / 4>::value * 2;
};

template <>
struct square_root<1> {
  static constexpr float value = 1.0f;
};

template <>
struct square_root<2> {
  static constexpr float value = 1.4142135623730951f;
};

// Constants such that multiplying the outputs of FastDCT<N>() by DCTScale<N>()
// is equivalent to SlowDCT<N>(); similarly for the inputs for IDCT. These
// constants are 1/sqrt(N) for this specific DCT implementation.
template <size_t N>
struct DCTScale {
  static constexpr float value = 1.0f / square_root<N>::value;
};
template <size_t N>
struct IDCTScale {
  static constexpr float value = 1.0f / square_root<N>::value;
};

// For n != 0, the n-th basis function of a N-DCT, evaluated in pixel k, has a
// value of cos((k+1/2) n/(2N) pi). When downsampling by 2x, we average
// the values for pixel k and k+1 to get the value for pixel (k/2), thus we get
//
// [cos((k+1/2) n/N pi) + cos((k+3/2) n/N pi)]/2 =
// cos(n/(2N) pi) cos((k+1) n/N pi) =
// cos(n/(2N) pi) cos(((k/2)+1/2) n/(N/2) pi)
//
// which is exactly the same as the value of pixel k/2 of a N/2-sized DCT,
// except for the cos(n/(2N) pi) scaling factor (which does *not*
// depend on the pixel). Thus, when using the lower-frequency coefficients of a
// DCT-N to compute a DCT-(N/2), they should be scaled by this constant. Scaling
// factors for a DCT-(N/4) etc can then be obtained by successive
// multiplications. The structs below contain the above-mentioned scaling
// factors.
template <size_t FROM, size_t TO>
struct DCTResampleScales;

template <>
struct DCTResampleScales<8, 1> {
  static constexpr float kScales[1] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<8, 2> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      0.906127446352887778,
  };
};

template <>
struct DCTResampleScales<16, 2> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      0.901764195028874394,
  };
};

template <>
struct DCTResampleScales<16, 4> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      0.976062531202202877,
      0.906127446352887778,
      0.795666809947927156,
  };
};

template <>
struct DCTResampleScales<32, 4> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      0.974886821136879522,
      0.901764195028874394,
      0.787054918159101335,
  };
};

template <>
struct DCTResampleScales<32, 8> {
  static constexpr float kScales[8] = {
      1.000000000000000000, 0.993985983084976765, 0.976062531202202877,
      0.946582901544112176, 0.906127446352887778, 0.855491189274751540,
      0.795666809947927156, 0.727823404688121345,
  };
};

// Inverses of the above.
template <>
struct DCTResampleScales<1, 8> {
  static constexpr float kScales[1] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<2, 8> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      1.103597517131772232,
  };
};

template <>
struct DCTResampleScales<2, 16> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      1.108937353592731823,
  };
};

template <>
struct DCTResampleScales<4, 16> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      1.024524523821556565,
      1.103597517131772232,
      1.256807482098500017,
  };
};

template <>
struct DCTResampleScales<4, 32> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      1.025760096781116015,
      1.108937353592731823,
      1.270559368765487251,
  };
};

template <>
struct DCTResampleScales<8, 32> {
  static constexpr float kScales[8] = {
      1.000000000000000000, 1.006050404147911470, 1.024524523821556565,
      1.056431505754806377, 1.103597517131772232, 1.168919110491081437,
      1.256807482098500017, 1.373959663235216677,
  };
};

// Constants for DCT implementation. Generated by the following snippet:
// for i in range(N // 2):
//    print(1.0 / (2 * math.cos((i + 0.5) * math.pi / N)), end=", ")
template <size_t N>
struct WcMultipliers;

template <>
struct WcMultipliers<4> {
  static constexpr float kMultipliers[2] = {
      0.541196100146197,
      1.3065629648763764,
  };
};

template <>
struct WcMultipliers<8> {
  static constexpr float kMultipliers[4] = {
      0.5097955791041592,
      0.6013448869350453,
      0.8999762231364156,
      2.5629154477415055,
  };
};

template <>
struct WcMultipliers<16> {
  static constexpr float kMultipliers[8] = {
      0.5024192861881557, 0.5224986149396889, 0.5669440348163577,
      0.6468217833599901, 0.7881546234512502, 1.060677685990347,
      1.7224470982383342, 5.101148618689155,
  };
};

template <>
struct WcMultipliers<32> {
  static constexpr float kMultipliers[16] = {
      0.5006029982351963, 0.5054709598975436, 0.5154473099226246,
      0.5310425910897841, 0.5531038960344445, 0.5829349682061339,
      0.6225041230356648, 0.6748083414550057, 0.7445362710022986,
      0.8393496454155268, 0.9725682378619608, 1.1694399334328847,
      1.4841646163141662, 2.057781009953411,  3.407608418468719,
      10.190008123548033,
  };
};
template <>
struct WcMultipliers<64> {
  static constexpr float kMultipliers[32] = {
      0.500150636020651,  0.5013584524464084, 0.5037887256810443,
      0.5074711720725553, 0.5124514794082247, 0.5187927131053328,
      0.52657731515427,   0.535909816907992,  0.5469204379855088,
      0.5597698129470802, 0.57465518403266,   0.5918185358574165,
      0.6115573478825099, 0.6342389366884031, 0.6603198078137061,
      0.6903721282002123, 0.7251205223771985, 0.7654941649730891,
      0.8127020908144905, 0.8683447152233481, 0.9345835970364075,
      1.0144082649970547, 1.1120716205797176, 1.233832737976571,
      1.3892939586328277, 1.5939722833856311, 1.8746759800084078,
      2.282050068005162,  2.924628428158216,  4.084611078129248,
      6.796750711673633,  20.373878167231453,
  };
};

// Apply the DCT algorithm-intrinsic constants to DCTResampleScale.
template <size_t FROM, size_t TO>
constexpr float DCTTotalResampleScale(size_t x) {
  return DCTResampleScales<FROM, TO>::kScales[x];
}

}  // namespace jxl

#endif  // JXL_DCT_SCALES_H_
