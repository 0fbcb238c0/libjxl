// Copyright (c) the JPEG XL Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef JXL_DCT_SCALES_H_
#define JXL_DCT_SCALES_H_

// Scaling factors.

#include <stddef.h>

namespace jxl {
template <size_t V>
struct square_root {
  static constexpr float value = square_root<V / 4>::value * 2;
};

template <>
struct square_root<1> {
  static constexpr float value = 1.0f;
};

template <>
struct square_root<2> {
  static constexpr float value = 1.4142135623730951f;
};

// For n != 0, the n-th basis function of a N-DCT, evaluated in pixel k, has a
// value of cos((k+1/2) n/(2N) pi). When downsampling by 2x, we average
// the values for pixel k and k+1 to get the value for pixel (k/2), thus we get
//
// [cos((k+1/2) n/N pi) + cos((k+3/2) n/N pi)]/2 =
// cos(n/(2N) pi) cos((k+1) n/N pi) =
// cos(n/(2N) pi) cos(((k/2)+1/2) n/(N/2) pi)
//
// which is exactly the same as the value of pixel k/2 of a N/2-sized DCT,
// except for the cos(n/(2N) pi) scaling factor (which does *not*
// depend on the pixel). Thus, when using the lower-frequency coefficients of a
// DCT-N to compute a DCT-(N/2), they should be scaled by this constant. Scaling
// factors for a DCT-(N/4) etc can then be obtained by successive
// multiplications. The structs below contain the above-mentioned scaling
// factors.
//
// Python code for the tables below:
//
// for i in range(N // 8):
//    v = math.cos(i / (2 * N) * math.pi)
//    v *= math.cos(i / (N) * math.pi)
//    v *= math.cos(i / (N / 2) * math.pi)
//    print(v, end=", ")

template <size_t FROM, size_t TO>
struct DCTResampleScales;

template <>
struct DCTResampleScales<8, 1> {
  static constexpr float kScales[1] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<16, 2> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      0.901764195028874394,
  };
};

template <>
struct DCTResampleScales<32, 4> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      0.974886821136879522,
      0.901764195028874394,
      0.787054918159101335,
  };
};

template <>
struct DCTResampleScales<64, 8> {
  static constexpr float kScales[8] = {
      1.0000000000000000, 0.9936866130906366, 0.9748868211368796,
      0.9440180941651672, 0.9017641950288744, 0.8490574973847023,
      0.7870549181591013, 0.7171081282466044,
  };
};

// Inverses of the above.
template <>
struct DCTResampleScales<1, 8> {
  static constexpr float kScales[1] = {
      1.000000000000000000,
  };
};

template <>
struct DCTResampleScales<2, 16> {
  static constexpr float kScales[2] = {
      1.000000000000000000,
      1.108937353592731823,
  };
};

template <>
struct DCTResampleScales<4, 32> {
  static constexpr float kScales[4] = {
      1.000000000000000000,
      1.025760096781116015,
      1.108937353592731823,
      1.270559368765487251,
  };
};

template <>
struct DCTResampleScales<8, 64> {
  static constexpr float kScales[8] = {
      1.0000000000000000, 1.0063534990068217, 1.0257600967811158,
      1.0593017296817173, 1.1089373535927318, 1.1777765381970435,
      1.2705593687654873, 1.3944898413647777,
  };
};

// Constants for DCT implementation. Generated by the following snippet:
// for i in range(N // 2):
//    print(1.0 / (2 * math.cos((i + 0.5) * math.pi / N)), end=", ")
template <size_t N>
struct WcMultipliers;

template <>
struct WcMultipliers<4> {
  static constexpr float kMultipliers[2] = {
      0.541196100146197,
      1.3065629648763764,
  };
};

template <>
struct WcMultipliers<8> {
  static constexpr float kMultipliers[4] = {
      0.5097955791041592,
      0.6013448869350453,
      0.8999762231364156,
      2.5629154477415055,
  };
};

template <>
struct WcMultipliers<16> {
  static constexpr float kMultipliers[8] = {
      0.5024192861881557, 0.5224986149396889, 0.5669440348163577,
      0.6468217833599901, 0.7881546234512502, 1.060677685990347,
      1.7224470982383342, 5.101148618689155,
  };
};

template <>
struct WcMultipliers<32> {
  static constexpr float kMultipliers[16] = {
      0.5006029982351963, 0.5054709598975436, 0.5154473099226246,
      0.5310425910897841, 0.5531038960344445, 0.5829349682061339,
      0.6225041230356648, 0.6748083414550057, 0.7445362710022986,
      0.8393496454155268, 0.9725682378619608, 1.1694399334328847,
      1.4841646163141662, 2.057781009953411,  3.407608418468719,
      10.190008123548033,
  };
};
template <>
struct WcMultipliers<64> {
  static constexpr float kMultipliers[32] = {
      0.500150636020651,  0.5013584524464084, 0.5037887256810443,
      0.5074711720725553, 0.5124514794082247, 0.5187927131053328,
      0.52657731515427,   0.535909816907992,  0.5469204379855088,
      0.5597698129470802, 0.57465518403266,   0.5918185358574165,
      0.6115573478825099, 0.6342389366884031, 0.6603198078137061,
      0.6903721282002123, 0.7251205223771985, 0.7654941649730891,
      0.8127020908144905, 0.8683447152233481, 0.9345835970364075,
      1.0144082649970547, 1.1120716205797176, 1.233832737976571,
      1.3892939586328277, 1.5939722833856311, 1.8746759800084078,
      2.282050068005162,  2.924628428158216,  4.084611078129248,
      6.796750711673633,  20.373878167231453,
  };
};
template <>
struct WcMultipliers<128> {
  static constexpr float kMultipliers[64] = {
      0.5000376519155477, 0.5003390374428216, 0.5009427176380873,
      0.5018505174842379, 0.5030651913013697, 0.5045904432216454,
      0.5064309549285542, 0.5085924210498143, 0.5110815927066812,
      0.5139063298475396, 0.5170756631334912, 0.5205998663018917,
      0.524490540114724,  0.5287607092074876, 0.5334249333971333,
      0.538499435291984,  0.5440022463817783, 0.549953374183236,
      0.5563749934898856, 0.5632916653417023, 0.5707305880121454,
      0.5787218851348208, 0.5872989370937893, 0.5964987630244563,
      0.606362462272146,  0.6169357260050706, 0.6282694319707711,
      0.6404203382416639, 0.6534518953751283, 0.6674352009263413,
      0.6824501259764195, 0.6985866506472291, 0.7159464549705746,
      0.7346448236478627, 0.7548129391165311, 0.776600658233963,
      0.8001798956216941, 0.8257487738627852, 0.8535367510066064,
      0.8838110045596234, 0.9168844461846523, 0.9531258743921193,
      0.9929729612675466, 1.036949040910389,  1.0856850642580145,
      1.1399486751015042, 1.2006832557294167, 1.2690611716991191,
      1.346557628206286,  1.4350550884414341, 1.5369941008524954,
      1.6555965242641195, 1.7952052190778898, 1.961817848571166,
      2.163957818751979,  2.4141600002500763, 2.7316450287739396,
      3.147462191781909,  3.7152427383269746, 4.5362909369693565,
      5.827688377844654,  8.153848602466814,  13.58429025728446,
      40.744688103351834,
  };
};

// Apply the DCT algorithm-intrinsic constants to DCTResampleScale.
template <size_t FROM, size_t TO>
constexpr float DCTTotalResampleScale(size_t x) {
  return DCTResampleScales<FROM, TO>::kScales[x];
}

}  // namespace jxl

#endif  // JXL_DCT_SCALES_H_
